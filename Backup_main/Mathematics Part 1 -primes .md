### 1.1 整除的定义  
对于两个**整数** $a,b$ $(a\ne0)$。如果存在一个**整数** $q$，使得 $b=aq$ ，则称 $b$ 可以被 $a$ 整除，记作 $a|b$。  
通俗地解释，当 $b$ 除以 $a$ 没有余数，即 $(b \bmod a = 0)$ 时，$a|b$。  

### 1.2 整除的性质  
1. 当 $a|b$ 时，$b$ 是 $a$ 的倍数， $a$ 是 $b$ 的因数。
3. 若 $a|b$ 且 $b|c$，则 $a|c$。
3. 若 $a|b$ 且 $a|c$，则对于任意的**整数** $x,y$，有 $a|(bx+cy)$。  
解释：$b$ 是 $a$ 的倍数，$c$ 也是 $a$ 的倍数，多个 $a$ 的倍数相加，结果必然也是 $a$ 的倍数。  
4. 若 $a|b$，则 $ma|mb$ $(m \ne 0)$。  
解释：十分显然的分式的基本性质。  
5. 若 $a|b$，则 $a$ 与 $b$ 有相同**种类**的质因数。

### 1.3 整除在OI中  
整除在OI中通常以**求一个数在一个范围里的所有约数、倍数**来出题。对于这一类题，我们有两种思路：  
$\hspace{0.5cm}$枚举一个数所有的约数（显而易见）  
$\hspace{0.5cm}$枚举这个数所有的倍数（一个数同时是多个比它大的数的约数，统计时必然会重复统计这个数，因此可以反向推导减少时间复杂度）  

### 1.4 好题链接  
* [洛谷P2926](https://www.luogu.com.cn/problem/P2926)   
[洛谷P1403](https://www.luogu.com.cn/problem/P1403)  


------------
### 2.1 质数与合数的定义  
有一个**除了0，1以外的正整数 $p$** ，如果它除了 1，$p$ 之外没有其他的约数，则称它为质数。如果不满足这个条件，则称 $p$ 为合数   

### 2.2 质数与合数的性质   

$\hspace{0.45cm}$1. 若 $a$ 为合数，则 $a$ 总能被表示为 $p \times q$，其中 $p,q$ 是**正实数**且满足 $1<p,q \hspace{0.4cm}p,q$ 中一定有一个数$\le\sqrt{a}$。  
$\hspace{0.45cm}$2. 若 $a$ 为合数，则一定有一个质数 $p$，使得 $p|a$ 且 $p\le\sqrt{n}$。
 
###  2.3 判断质数  
 判断质数一直是一些题目中的考点甚至是一些准备工作，以下是一些判断质数的方法（**这里仅讨论算法实现的方法及证明，关于具体代码，见算法合集章节**）  
####  $\hspace{0.5cm}$2.3.1 判断一个数 $n$ 是质数  
$\hspace{0.5cm}$根据性质 Part1-2.2.1，我们自然想到在区间 $[2-\sqrt{n}]$ 中枚举所有的 $p$，不停用 $p$ 试除 $n$，如果有一次试除没有余数，则 $n$ 为合数，反之则为质数。时间复杂度 $O(\sqrt{n})$。  

#### $\hspace{0.5cm}$2.3.2 素数筛法  
$\hspace{0.5cm}$ $O(\sqrt{n})$ 判断质数的方法已经比较优秀了，但是当我们遇到 $n$ 的数量极多（以下将 $n$ 的数量记为 $m$ ）的情况下，时间复杂度就会至约 $O(m\sqrt{m})$ 。仅仅是一个素数判断就要消耗如此多的时间，这显然是不能接受的。那么我们便想到了预处理。提前预处理出范围内的质数有哪些，之后便可以 $O(1)$ 访问了。那么该如何预处理呢？  

#### $\hspace{0.5cm}$ $\hspace{0.5cm}$2.3.2.1 埃拉托尼斯筛（埃氏筛）  
$\hspace{1cm}$埃氏筛的思想就是用质数乘倍数，并作标记，表示删去这个合数，那么这个算法正确吗，接下来让我们证明一下：  
$\hspace{1cm}$**1**.为什么只用质数筛除就行? 我们根据性质Part1-2.2.2，可知如果这个数是合数，则一定至少有一个比他小的质因数会通过乘倍数将它标记，因此仅需质数筛除即可，用其他合数是没有必要的。  
$\hspace{1cm}$**2**.为什么当枚举到这里时，如果它还未被标记，那么它一定是质数？  
$\hspace{1cm}$同样根据性质 Part1-2.2.2，如果它还未被标记，则意味着它在从2到这的区间中没有一个质因数，那么显然它一定是质数了。  
$\hspace{1cm}$**3**.为什么只需要枚举到 $O(\sqrt{m})$ ?   
$\hspace{1cm}$依然是性质 Part1-2.2.2，若 $a$ 为合数，则一定有一个质数 $p$，使得 $p|a$ 且 $p\le\sqrt{a
}$，因此最大的 $p$ 只到 $(\sqrt{m})$，所以无需再枚举后面的数了。  
$\hspace{1cm}$埃氏筛是一种高效且简单易懂的算法，他的时间复杂度是 $O(m\log{\log m})$ 。观察函数图像可以看出确实比 $O(m\sqrt{m})$ 优化了不少，但是还有没有更快的算法呢？  
#### $\hspace{0.5cm}$ $\hspace{0.5cm}$2.3.2.2 欧拉筛（线性筛）  

$\hspace{1cm}$埃氏筛虽然已经很快了，但是它未免还会有一些重复的运算操作，例如它会将6这个数重复标记两遍。有没有一种算法可以避免这样重复的操作呢？欧拉筛就可以，它的时间复杂度是 $O(m)$ 。让我们先来了解它的基本原理：  
$\hspace{1cm}$假设要筛出 $m$ 以内的素数。我们先把所有数标记为素数。枚举 $i$ 从2到 $m$，如果 $i$ 没有被前面的数（比它小的数）标记为合数，那 $i$ 就是素数，加入素数列表（如埃氏筛的证明2）。现在用 $i$ 来筛后面的数，枚举已经筛出来的素数 $prime[j]$，标记 $i * prime[j]$ 为合数，当 $i$ 是 $prime[j]$ 的倍数时退出循环。  
$\hspace{1cm}$可以看出，欧拉筛的实现思路和埃氏筛是类似的，都是通过乘倍数并进行标记，但是欧拉筛增加了质数的存储并在循环中加入的一个跳出语句，虽然这有点让人怀疑它能否准确排除素数，但这就是它优化时间的关键  
$\hspace{1cm}$**接下来我们先证明它排除素数的方法是对的：**  
$\hspace{1cm}$我们设一个合数 $a$ ，那么这个 $a$ 可以表示为 $a=qi$，其中 $q$ 为 $a$ 的最小质因数。那么很显然此时 $i|a$。所以根据性质Part1-1.2.5，$a$ 与 $i$ 有相同种类的质因数，即 $i$ 的最小质因数一定不小于 $a$ 的最小质因数。
因为 $prime[i]$ 中装的都是质数且从小到大排序，所以在 $i$ 的最小质因数等于 $prime[i]$ 前（即触发break条件前），$i$ 会将这之前的所有 $i* prime[i]$ 全部标记，这其中就一定包括 $a$。又因为 $a$ 是全体合数，所以这个算法可以正确的排除所有的合数。  
$\hspace{1cm}$**既然正确性已经证明，接下来我们证明他的时间复杂度是 $O(m)$。其实也就是证明它的每一个数都没有被重复标记。**  
$\hspace{1cm}$我们设此时取到的质数为 $prime[j]$，且此时满足break条件 $i \bmod prime[j]=0$。  
$\hspace{1cm}$由于break语句在赋值语句之后，因此他会先给 $i * prime[j] $ 处赋值。那么此时退出条件的这个式子也可以写成 $i = k * prime[j] $  的样子，其中 $k= \dfrac{i}{prime[j]} $ ，记这个式子为**一式**。  
$\hspace{1cm}$我们不妨认为此时break语句不存在，即这之后程序不会退出循环，则它下一个应给 $i * prime[j+1] $ 处赋值。我们记这个数为 $X$，记式子 $i * prime[j+1] $ 为**二式**。  
$\hspace{1cm}$我们将一式带入二式，可得  
$$k * prime[j]* prime[j+1] = X$$  
$\hspace{1cm}$我们将 $k * prime[j+1]$ 设为 $i'$，则有:
$$prime[j]* i' = X$$  
$\hspace{1cm}$此时对比二式我们发现，当 $i'=i$ 时，$X$ 被重复赋值，这显然不是我们想要的，因此应在 $i \bmod prime[j]=0$ 时退出以避免浪费时间。  

判断质数的方法固然只需要背过板子就可以了，但是通过倍数筛质数的方法有时在一些值范围很大的时候配合上性质可能有奇妙的用法。  
### 2.4 好题链接  
* [洛谷P1835](https://www.luogu.com.cn/problem/P1835)  
[洛谷 模板 P3383](https://www.luogu.com.cn/problem/P3383)  


------------  
##### 迁移自[云剪贴板](https://www.luogu.com.cn/paste/w7fho8uc)

