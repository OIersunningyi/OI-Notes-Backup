### 前言  
自动 AC 机（大喜  
名字听起来很高级，实际上是个大杂烩。  
前置知识：[KMP 算法](https://www.luogu.com.cn/article/732q5qbx)，[Trie 树](https://www.luogu.com.cn/article/aji3g9ze)  
## 1. 是什么  
`AC` 是两个人名的缩写，分别是 Alfred V. Aho 和 Margaret J. Corasick.。膜拜Orz  
至于 “自动机”，并非单词 `Automation`，而是 `Automaton`。  
我们学过的 KMP 算法是在若干个主串里匹配快速匹配一个模式串。但在 AC 自动机中，我们要做的是在若干个主串里快速匹配若干个模式串。  
两种算法的大体思路是相同的：当某一处失配时，通过跳转到一个特定的位置而非从头开始匹配来节省时间。但是 KMP 算法将跳转到的位置在一个字符串中，而 AC 自动机将跳转到的位置在一棵 Trie 中。  
而且，AC 自动机不直接使用 `next` 数组进行跳转，而是利用 `next` 数组跳转的位置，在匹配时尽可能多的跳转到表示不同模式串的树链上并记录尽可能多的答案。  
在 AC 自动机中，一般把存储 “失配时，通过跳转到一个特定的位置” 的数组叫做 `fail` 数组。
虽然由线性数据结构变成了树形数据结构，但是好像更好理解了？    

先来看看 AC 自动机的 `fail` 数组表示什么。放张图：  
![](https://cdn.luogu.com.cn/upload/image_hosting/6svyapsm.png)   
对于节点 $u$，设从根节点到 $u$ 组成的字符串为 $S$，从根节点到 `fail[u] ` 组成的字符串为 $S'$，如上图所示。  
那么 $S'$ 一定是 $S$ 的后缀子串，且一定是 $S$ 的后缀子串中，能在 Trie 树中找到的，从根节点开始的字符串中最长的。   
这里与 KMP 算法不同的是，KMP 算法的 `next` 指针指向自己的存在的最长相等前缀后缀子串的位置，而 AC 自动机指向的不止是自己，还可能是其他模式串的前缀子串。
## 2. 怎么建  
首先我们将给定的模式串按从左到右的顺序放到一棵 Trie 中，这一步很简单。  
接下来就是最恶心人的求解 `fail` 数组的过程了。  
首先，由于 Trie 是一棵树，而 `fail` 数组需要用父亲节点的 `fail` 更新而来，因此我们使用 BFS，从根节点向下搜索，确保要求解 `fail` 的节点的父亲节点的 `fail` 已经被求出。  
接下来我们假设要求解 `u` 节点对应的所有 `son[u][i]`，即所有儿子节点的 `fail`。我们遍历所有 `son[u][i]`，此时分两种情况：  
- `son[u][i]` 不为零，即可以通过一条代表 `i` 的边到达一个点，此时我们把它的 `fail` 的情况放到与主串匹配时来看会更好理解。放张图：  
  ![](https://cdn.luogu.com.cn/upload/image_hosting/ewqkc05p.png)  
  上图中，我们假设红色串与主串匹配的过程中在 `son[u]['z']` 处失配（AC 自动机实际情况的匹配不是这个原理，这里只是举例便于理解）  
  那么可以知道，先前的 `...，u,v,w,z` 字符一定已经与主串匹配。  
  此时，`fail[u]` 代表的蓝色串中 `....,v,w,z` 字符也一定与主串匹配（$S'$ 是 $S$ 的后缀子串）。  
  由于 `fail[u]` 代表的 `u` 的后缀子串是最长的，因此其用 `z` 边连接的儿子 `son[fail[u]]['z']`，也一定是代表 `son[u]['z']` 的最长后缀子串。  
  因此 `son[fail[u]]['z']` 满足我们对`son[u]['z']` 的 `fail` 节点的定义，所以：  
  `fail[son[u]['z']]=son[fail[u]]['z']`  
  进一步，我们可以推广到所有代表不同类型字符的边，因此可以写出如下代码：     
  ```cpp
  for(int i=0;i<26;i++){
      int p=son[u][i];
  	  if(p){//son[u][i] 不为零时：
          nxt[p]=son[nxt[u]][i];
  	      q.push(p);//把这个点也放入 BFS 队列中
      }
      ...
  }  
  ```  
你可能有疑问：如果 `son[fail[u]]['z']` 的值是 $0$ 会怎样？可能 `fail` 指针需要跳转不止一次才能取到正确答案，这里是怎样保证正确的呢？   
解决这个问题的方法在 `son[u][i]` 为零的情况里：  
对于 `son[u][i]` 为零的情况，也就是没有 $i$ 这条边和其连接的点，我们直接改变 Trie 树的结构，将它赋值给 `son[fail[u]][i]`。  
似乎是一个很奇怪的操作，来看看有什么用：  





